# -*- coding: utf-8 -*-
"""task3_future_forecast.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15N7Wmo847pvzW4T9cJHPL71FwuZDp2Es
"""

# ==============================
# Task 3: Future Forecasts (TSLA)
# ARIMA with 95% CIs + optional LSTM points
# ==============================

# -- Installs --
!pip install -q yfinance pmdarima tensorflow==2.12.0

# -- Imports --
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pmdarima as pm
from datetime import timedelta
from sklearn.preprocessing import MinMaxScaler
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

np.random.seed(42)
tf.random.set_seed(42)
plt.rcParams["figure.figsize"] = (12,6)

# --------------------------
# 1) Load historical prices
# --------------------------
ticker = "TSLA"
start_date = "2015-07-01"
end_date   = "2025-07-31"   # align to your dataset end

raw = yf.download(ticker, start=start_date, end=end_date, progress=False)
if raw.empty:
    raise SystemExit("No data returned—check ticker/dates.")

price_col = "Adj Close" if "Adj Close" in raw.columns else "Close"
if price_col != "Adj Close":
    print("⚠️ 'Adj Close' missing; using 'Close' instead.")

ts = raw[[price_col]].rename(columns={price_col:"AdjClose"}).dropna()
ts.index = pd.to_datetime(ts.index)
ts = ts.sort_index()

print(f"Loaded {len(ts)} rows. Range: {ts.index.min().date()} → {ts.index.max().date()}")

# ------------------------------------
# 2) Choose forecast horizon (6–12 mo)
# ------------------------------------
trading_days_per_year = 252
horizon_days = trading_days_per_year // 2   # ~6 months; set to 252 for ~12 months

# ------------------------------------
# 3) ARIMA fit on full history (log)
# ------------------------------------
print("\n--- Fitting ARIMA (auto_arima) for CI forecasts ---")
y_log = np.log(ts["AdjClose"].values)

arima = pm.auto_arima(
    y_log,
    seasonal=False,
    stepwise=True,
    suppress_warnings=True,
    error_action="ignore",
    max_p=6, max_q=6,
    trace=False
)
print("Chosen ARIMA order:", arima.order)

# Forecast with 95% CI
fc_log, conf_log = arima.predict(n_periods=horizon_days, return_conf_int=True, alpha=0.05)
fc    = np.exp(fc_log)
lower = np.exp(conf_log[:,0])
upper = np.exp(conf_log[:,1])

# Create future index (business days to align with market)
last_date = ts.index[-1]
future_idx = pd.bdate_range(start=last_date + pd.Timedelta(days=1), periods=horizon_days)

arima_df = pd.DataFrame({
    "ARIMA_Forecast": fc,
    "ARIMA_Lower95":  lower,
    "ARIMA_Upper95":  upper
}, index=future_idx)

# ------------------------------------
# 4) Optional: LSTM point forecasts
# ------------------------------------
use_lstm = True
lstm_df = None

if use_lstm:
    print("\n--- Training LSTM for point forecasts (no CI) ---")
    lookback = 60

    scaler = MinMaxScaler((0,1))
    y = ts["AdjClose"].values.reshape(-1,1)
    y_scaled = scaler.fit_transform(y)

    # Make sequences on full history
    X, tgt = [], []
    for i in range(lookback, len(y_scaled)):
        X.append(y_scaled[i-lookback:i, 0])
        tgt.append(y_scaled[i, 0])
    X = np.array(X).reshape(-1, lookback, 1)
    tgt = np.array(tgt)

    # Simple LSTM
    tf.keras.backend.clear_session()
    model = Sequential([
        LSTM(64, return_sequences=True, input_shape=(lookback,1)),
        Dropout(0.2),
        LSTM(32),
        Dropout(0.2),
        Dense(1)
    ])
    model.compile(optimizer="adam", loss="mse")
    model.fit(X, tgt, epochs=50, batch_size=32, validation_split=0.1, verbose=0)

    # Recursive multi-step forecast
    last_window = y_scaled[-lookback:, 0].copy()
    preds_scaled = []
    for _ in range(horizon_days):
        inp = last_window.reshape(1, lookback, 1)
        next_scaled = model.predict(inp, verbose=0)[0,0]
        preds_scaled.append(next_scaled)
        last_window = np.append(last_window[1:], next_scaled)

    lstm_preds = scaler.inverse_transform(np.array(preds_scaled).reshape(-1,1)).ravel()
    lstm_df = pd.DataFrame({"LSTM_Forecast": lstm_preds}, index=future_idx)

# ------------------------------------
# 5) Plot: Historical + Forecast + CI
# ------------------------------------
plt.figure(figsize=(14,6))
plt.plot(ts.index, ts["AdjClose"], label="Historical", color="black")

plt.plot(arima_df.index, arima_df["ARIMA_Forecast"], label="ARIMA Forecast", linewidth=2)
plt.fill_between(
    arima_df.index,
    arima_df["ARIMA_Lower95"],
    arima_df["ARIMA_Upper95"],
    alpha=0.2, label="ARIMA 95% CI"
)

if lstm_df is not None:
    plt.plot(lstm_df.index, lstm_df["LSTM_Forecast"], label="LSTM Forecast", alpha=0.8)

plt.title(f"TSLA — {horizon_days}-Day Forecast (6–12 months)")
plt.xlabel("Date"); plt.ylabel("USD"); plt.legend()
plt.show()

# ------------------------------------
# 6) Quick analytics on CI & trend
# ------------------------------------
ci_width = (arima_df["ARIMA_Upper95"] - arima_df["ARIMA_Lower95"])
print("\n--- Forecast Diagnostics ---")
print(f"Initial CI width: ${ci_width.iloc[0]:.2f}")
print(f"Final   CI width: ${ci_width.iloc[-1]:.2f}")
print(f"Change in CI width over horizon: ${ci_width.iloc[-1]-ci_width.iloc[0]:.2f}")
print(f"Median CI width: ${ci_width.median():.2f}")

# Trend proxy: compare start/end forecast medians
first_month = arima_df["ARIMA_Forecast"].iloc[:21].median()
last_month  = arima_df["ARIMA_Forecast"].iloc[-21:].median()
trend = "upward 📈" if last_month > first_month else ("downward 📉" if last_month < first_month else "flat ➖")
print(f"Trend proxy (first vs last 1-month median): {trend}")
print(f"First-month median: ${first_month:.2f} | Last-month median: ${last_month:.2f}")

print("\n--- Interpretation Hints ---")
print("- If CI bands widen over time, uncertainty grows → long-range forecasts less reliable.")
print("- ARIMA CIs are statistically grounded; LSTM line is a point estimate without intervals here.")
print("- Inspect trend proxy above to discuss potential opportunities (uptrend) or risks (downtrend/high uncertainty).")