# -*- coding: utf-8 -*-
"""task4_portfolio_optimization.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15N7Wmo847pvzW4T9cJHPL71FwuZDp2Es
"""

# ==============================
# Task 4: Portfolio Optimization
# TSLA expected return from ARIMA forecast;
# BND & SPY expected returns from historical averages
# Efficient Frontier with PyPortfolioOpt
# ==============================

!pip install -q yfinance pmdarima PyPortfolioOpt

import warnings
warnings.filterwarnings("ignore")

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pmdarima as pm
from datetime import datetime, timedelta

from pypfopt import EfficientFrontier, risk_models, expected_returns, plotting, objective_functions, DiscreteAllocation

plt.rcParams["figure.figsize"] = (12, 7)
np.random.seed(42)

# --------------------------
# 1) Download price history
# --------------------------
assets = ["TSLA", "BND", "SPY"]
start = "2015-07-01"
end   = "2025-07-31"

prices_raw = yf.download(assets, start=start, end=end, auto_adjust=False, progress=False)

# Pick Adj Close if available, else Close
if ("Adj Close" in prices_raw.columns.get_level_values(0)):
    prices = prices_raw["Adj Close"].copy()
else:
    prices = prices_raw["Close"].copy()
prices = prices.dropna(how="any")

# Sanity check
if prices.empty or prices.shape[0] < 300:
    raise SystemExit("Not enough price data. Check tickers/dates or rerun.")

# -------------------------------------------
# 2) Build TSLA expected return from forecast
# -------------------------------------------
tsla = prices["TSLA"].to_frame("TSLA")
tsla_log = np.log(tsla["TSLA"].values)

# Fit quick ARIMA via auto_arima
arima = pm.auto_arima(
    tsla_log,
    seasonal=False,
    stepwise=True,
    suppress_warnings=True,
    error_action="ignore",
    max_p=6, max_q=6,
    trace=False
)

# Forecast next 252 trading days (~12 months)
h = 252
fc_log = arima.predict(n_periods=h)                 # log-price forecasts
fc_prices = np.exp(fc_log)                          # back to level
# Expected daily returns from forecast path
fc_returns_daily = pd.Series(fc_prices).pct_change().dropna()
# Convert to expected annual return (approx; 252 trading days)
tsla_expected_return_annual = (1 + fc_returns_daily.mean())**252 - 1

# ---------------------------------------------
# 3) Expected returns for BND & SPY (historical)
# ---------------------------------------------
# Use last 5 years of data for stability (fallback to all if not enough)
cutoff = prices.index.max() - pd.tseries.offsets.BDay(252*5)
hist_window = prices.loc[prices.index >= cutoff] if (prices.index >= cutoff).sum() > 300 else prices

daily_returns = hist_window.pct_change().dropna()

# Annualized historical mean returns for BND & SPY
bnd_expected_return_annual = (1 + daily_returns["BND"].mean())**252 - 1
spy_expected_return_annual = (1 + daily_returns["SPY"].mean())**252 - 1

# Compose expected returns vector in the order of 'assets'
mu_vec = pd.Series(
    {
        "TSLA": tsla_expected_return_annual,
        "BND":  bnd_expected_return_annual,
        "SPY":  spy_expected_return_annual,
    }
).reindex(assets)

print("=== Expected Annual Returns (from forecast/historical) ===")
print(mu_vec.apply(lambda x: f"{x*100:.2f}%"))

# ------------------------------------------------
# 4) Covariance matrix from historical returns
# ------------------------------------------------
# Use sample covariance of daily returns, annualized
S = risk_models.sample_cov(hist_window.pct_change().dropna(), frequency=252)

# ---------------------------------------------
# 5) Efficient Frontier Optimization (long-only)
# ---------------------------------------------
# Risk-free rate (annual). Adjust to your macro view if needed.
risk_free_rate = 0.02

ef = EfficientFrontier(mu_vec, S, weight_bounds=(0.0, 1.0))
ef.add_objective(objective_functions.L2_reg, gamma=0.001)  # tiny regularization for stability

# Max Sharpe portfolio
w_ms = ef.max_sharpe(risk_free_rate=risk_free_rate)
cleaned_w_ms = ef.clean_weights()
ms_perf = ef.portfolio_performance(verbose=False, risk_free_rate=risk_free_rate)

# Rebuild EF for min vol (PyPortfolioOpt mutates internal state)
ef_min = EfficientFrontier(mu_vec, S, weight_bounds=(0.0, 1.0))
ef_min.add_objective(objective_functions.L2_reg, gamma=0.001)
w_mv = ef_min.min_volatility()
cleaned_w_mv = ef_min.clean_weights()
mv_perf = ef_min.portfolio_performance(verbose=False, risk_free_rate=risk_free_rate)

print("\n=== Max Sharpe Portfolio (Tangency) ===")
print(pd.Series(cleaned_w_ms).loc[lambda s: s>1e-4].round(4))
print(f"Expected annual return: {ms_perf[0]*100:.2f}%")
print(f"Annual volatility:      {ms_perf[1]*100:.2f}%")
print(f"Sharpe Ratio:           {ms_perf[2]:.2f}")

print("\n=== Minimum Volatility Portfolio ===")
print(pd.Series(cleaned_w_mv).loc[lambda s: s>1e-4].round(4))
print(f"Expected annual return: {mv_perf[0]*100:.2f}%")
print(f"Annual volatility:      {mv_perf[1]*100:.2f}%")
print(f"Sharpe Ratio:           {mv_perf[2]:.2f}")

# ---------------------------------------------
# 6) Plot Efficient Frontier + Key Portfolios
# ---------------------------------------------
# Generate random portfolios to plot frontier
n_samples = 3000
mus = []
vols = []

wts = np.random.dirichlet(np.ones(len(assets)), n_samples)
for w in wts:
    ret = float(np.dot(mu_vec.values, w))
    vol = float(np.sqrt(np.dot(w.T, np.dot(S.values, w))))
    mus.append(ret)
    vols.append(vol)

plt.figure(figsize=(12,7))
plt.scatter(vols, mus, s=6, alpha=0.25, label="Random Portfolios")

# Points for Max Sharpe and Min Vol
ms_w = pd.Series(cleaned_w_ms).values
mv_w = pd.Series(cleaned_w_mv).values

ms_ret = float(np.dot(mu_vec.values, ms_w))
ms_vol = float(np.sqrt(np.dot(ms_w.T, np.dot(S.values, ms_w))))

mv_ret = float(np.dot(mu_vec.values, mv_w))
mv_vol = float(np.sqrt(np.dot(mv_w.T, np.dot(S.values, mv_w))))

plt.scatter([ms_vol], [ms_ret], marker="*", s=250, label="Max Sharpe", zorder=5)
plt.scatter([mv_vol], [mv_ret], marker="P", s=200, label="Min Vol", zorder=5)

plt.title("Efficient Frontier — TSLA (forecast), BND & SPY (historical)")
plt.xlabel("Annual Volatility (σ)")
plt.ylabel("Expected Annual Return (μ)")
plt.legend()
plt.grid(alpha=0.3)
plt.show()

# ---------------------------------------------
# 7) Simple recommendation (pick Max Sharpe)
# ---------------------------------------------
print("\n=== Recommended Portfolio (Max Sharpe) ===")
rec = pd.Series(cleaned_w_ms).round(4)
print(rec.loc[rec>1e-4])
print(f"→ Exp. Return: {ms_perf[0]*100:.2f}%, Volatility: {ms_perf[1]*100:.2f}%, Sharpe: {ms_perf[2]:.2f}")
print("\nRationale: Maximizes risk-adjusted return given expected returns (TSLA from forecast) and covariances.")